<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Corec_Upto_step (Isabelle2014: August 2014)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Corec_Upto_step</h1>

<span class="command">theory</span> <span class="name">Corec_Upto_step</span><br/>
<span class="keyword">imports</span> <a href="Lift_to_Free_step.html"><span class="name">Lift_to_Free_step</span></a><br/>

</div>
<div class="source">
<pre><span class="command">header</span> <span class="verbatim">{* Corecursion and coinduction up to *}</span>

<span class="command">theory</span> Corec_Upto_step
<span class="keyword2">imports</span> Lift_to_Free_step
<span class="keyword2">begin</span>


<span class="command">subsection</span><span class="verbatim">{* The algebra associated to dd_step *}</span>

<span class="command">definition</span> <span class="string">&quot;eval_step &equiv; dtor_unfold_J (dd_step o &Sigma;&Sigma;_step_map &lt;id, dtor_J&gt;)&quot;</span>

<span class="command">lemma</span> eval_step<span class="delimiter">:</span> <span class="string">&quot;F_map eval_step o dd_step o &Sigma;&Sigma;_step_map &lt;id, dtor_J&gt; = dtor_J o eval_step&quot;</span>
  <span class="command">unfolding</span> eval_step_def dtor_unfold_J_pointfree <span class="command">unfolding</span> o_assoc <span class="command">..</span>

<span class="command">lemma</span> eval_step_ctor_J<span class="delimiter">:</span> <span class="string">&quot;ctor_J o F_map eval_step o dd_step o &Sigma;&Sigma;_step_map &lt;id, dtor_J&gt; = eval_step&quot;</span>
  <span class="command">unfolding</span> o_def spec<span class="delimiter">[</span>OF eval_step<span class="delimiter">[</span>unfolded o_def fun_eq_iff<span class="delimiter">]</span><span class="delimiter">]</span> J.ctor_dtor <span class="command">..</span>

<span class="command">lemma</span> eval_step_leaf_step<span class="delimiter">:</span> <span class="string">&quot;eval_step o leaf_step = id&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>rule trans<span class="delimiter">)</span>
  <span class="command">show</span> <span class="string">&quot;eval_step o leaf_step = dtor_unfold_J dtor_J&quot;</span>
  <span class="command">apply</span><span class="delimiter">(</span>rule J.dtor_unfold_unique<span class="delimiter">)</span>
  <span class="command">unfolding</span> o_assoc eval_step<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> leaf_step_natural
  <span class="command">apply</span><span class="delimiter">(</span>rule sym<span class="delimiter">)</span>
  <span class="command">unfolding</span> F_map_comp o_assoc <span class="command">apply</span> <span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> dd_step_leaf_step <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">by</span> simp
<span class="command">qed</span><span class="delimiter">(</span>metis F_map_id J.dtor_unfold_unique fun.map_id o_id<span class="delimiter">)</span>

<span class="command">lemma</span> eval_step_flat_step<span class="delimiter">:</span> <span class="string">&quot;eval_step o flat_step = eval_step o &Sigma;&Sigma;_step_map eval_step&quot;</span>
<span class="command">proof</span> <span class="delimiter">(</span>rule trans<span class="delimiter">)</span>
  <span class="command">let</span> <span class="var">?K_step</span> <span class="delimiter">=</span> <span class="string">&quot;dtor_unfold_J (dd_step o &Sigma;&Sigma;_step_map &lt;&Sigma;&Sigma;_step_map fst, dd_step&gt; o &Sigma;&Sigma;_step_map (&Sigma;&Sigma;_step_map &lt;id, dtor_J&gt;))&quot;</span>
  <span class="command">show</span> <span class="string">&quot;eval_step o flat_step = ?K_step&quot;</span>
  <span class="command">apply</span><span class="delimiter">(</span>rule J.dtor_unfold_unique<span class="delimiter">)</span>
  <span class="command">unfolding</span> F_map_comp o_assoc
  <span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">,</span> subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> dd_step_flat_step
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> &Sigma;&Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> snd_convol
  <span class="command">unfolding</span> flat_step_natural
  <span class="command">unfolding</span> o_assoc eval_step <span class="command">..</span>
  <span class="comment">(*  *)</span>
  <span class="command">have</span> A<span class="delimiter">:</span> <span class="string">&quot;&lt;eval_step, dtor_J o eval_step&gt; = &lt;id,dtor_J&gt; o eval_step&quot;</span> <span class="command">by</span> simp
  <span class="command">show</span> <span class="string">&quot;?K_step = eval_step o &Sigma;&Sigma;_step_map eval_step&quot;</span>
  <span class="command">apply</span><span class="delimiter">(</span>rule J.dtor_unfold_unique<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> &Sigma;&Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> map_prod_o_convol id_o
  <span class="command">unfolding</span> F_map_comp o_assoc
  <span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span> <span class="command">unfolding</span> dd_step_natural<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> &Sigma;&Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> o_assoc <span class="command">unfolding</span> map_prod_o_convol <span class="command">unfolding</span> convol_o
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> &Sigma;&Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> fst_convol &Sigma;&Sigma;_step.map_id0 o_id
  <span class="command">unfolding</span> o_assoc eval_step <span class="command">unfolding</span> A <span class="command">unfolding</span> convol_o id_o
  <span class="command">apply</span><span class="delimiter">(</span>rule sym<span class="delimiter">)</span> <span class="command">apply</span><span class="delimiter">(</span>subst eval_step<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> &Sigma;&Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> convol_o id_o <span class="command">..</span>
<span class="command">qed</span>


<span class="command">subsection</span><span class="verbatim">{* The correspondence between coalgebras up to and coalgebras *}</span>

<span class="comment">(* This correspondence, and add_step the lemmas of this subsection, make
sense not only for (J,dtor_J,eval_step), but also for any dd_step-bialgebra *)</span>

<span class="comment">(* Coalgebra-up-to to coalgebra and vice versa: *)</span>
<span class="command">definition</span> cut&Sigma;&Sigma;_stepOc <span class="delimiter">::</span> <span class="string">&quot;(&#39;a =&gt; &#39;a &Sigma;&Sigma;_step F) =&gt; (&#39;a &Sigma;&Sigma;_step =&gt; &#39;a &Sigma;&Sigma;_step F)&quot;</span>
<span class="keyword2">where</span> <span class="string">&quot;cut&Sigma;&Sigma;_stepOc s &equiv; F_map flat_step o dd_step o &Sigma;&Sigma;_step_map &lt;leaf_step, s&gt;&quot;</span>
<span class="command">definition</span> c&Sigma;&Sigma;_stepOcut <span class="delimiter">::</span> <span class="string">&quot;(&#39;a &Sigma;&Sigma;_step =&gt; &#39;a &Sigma;&Sigma;_step F) =&gt; (&#39;a =&gt; &#39;a &Sigma;&Sigma;_step F)&quot;</span>
<span class="keyword2">where</span> <span class="string">&quot;c&Sigma;&Sigma;_stepOcut s&#39; &equiv; s&#39; o leaf_step&quot;</span>

<span class="command">lemma</span> c&Sigma;&Sigma;_stepOcut_cut&Sigma;&Sigma;_stepOc<span class="delimiter">:</span> <span class="string">&quot;c&Sigma;&Sigma;_stepOcut (cut&Sigma;&Sigma;_stepOc s) = s&quot;</span>
<span class="command">unfolding</span> c&Sigma;&Sigma;_stepOcut_def cut&Sigma;&Sigma;_stepOc_def
<span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> leaf_step_natural
<span class="command">unfolding</span> o_assoc <span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
<span class="command">unfolding</span> dd_step_leaf_step <span class="command">unfolding</span> o_assoc F_map_comp<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> flat_step_leaf_step
<span class="command">unfolding</span> F_map_id id_o <span class="command">by</span> simp

<span class="command">lemma</span> cut&Sigma;&Sigma;_stepOc_inj<span class="delimiter">:</span> <span class="string">&quot;cut&Sigma;&Sigma;_stepOc s_step = cut&Sigma;&Sigma;_stepOc s2 &lt;-&gt; s_step = s2&quot;</span>
<span class="command">by</span> <span class="delimiter">(</span>metis c&Sigma;&Sigma;_stepOcut_cut&Sigma;&Sigma;_stepOc<span class="delimiter">)</span>

<span class="command">lemma</span> c&Sigma;&Sigma;_stepOcut_surj<span class="delimiter">:</span> <span class="string">&quot;&exist; s&#39;. c&Sigma;&Sigma;_stepOcut s&#39; = s&quot;</span>
<span class="command">using</span> c&Sigma;&Sigma;_stepOcut_cut&Sigma;&Sigma;_stepOc <span class="command">by</span><span class="delimiter">(</span>rule exI<span class="delimiter">[</span>of _ <span class="string">&quot;cut&Sigma;&Sigma;_stepOc s&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>

<span class="comment">(* Morphism-up-to to morphism and vice versa: *)</span>
<span class="comment">(* The dd_step-extension of a function *)</span>
<span class="command">definition</span> extdd_step <span class="delimiter">::</span> <span class="string">&quot;(&#39;a =&gt; J) =&gt; (&#39;a &Sigma;&Sigma;_step =&gt; J)&quot;</span>
<span class="keyword2">where</span> <span class="string">&quot;extdd_step f &equiv; eval_step o &Sigma;&Sigma;_step_map f&quot;</span>
<span class="comment">(* The restriction of a function *)</span>  <span class="command">term</span> eval_step
<span class="command">definition</span> restr <span class="delimiter">::</span> <span class="string">&quot;(&#39;a &Sigma;&Sigma;_step =&gt; J) =&gt; (&#39;a =&gt; J)&quot;</span>
<span class="keyword2">where</span> <span class="string">&quot;restr f&#39; &equiv; f&#39; o leaf_step&quot;</span>

<span class="comment">(* We think of extdd_step and restr as operating
extdd_step : Hom_dd_step(s,dtor_J) -&gt; Hom(cut&Sigma;&Sigma;_stepOc s,dtor_J) and
restr : Hom(cut&Sigma;&Sigma;_stepOc s,dtor_J) -&gt; Hom_dd_step(s,dtor_J), where
Hom(cut&Sigma;&Sigma;_stepOc s,dtor_J) is the set of coalgebra morphisms betwee cut&Sigma;&Sigma;_stepOc s and dtor_J and
Hom_dd_step(s,dtor_J) is the set of coalgebra up-to-dd_step-morphisms between s and dtor_J  *)</span>

<span class="comment">(* extdd_step is wedd_step-defined: *)</span>
<span class="command">lemma</span> extdd_step_mor<span class="delimiter">:</span>
<span class="keyword2">assumes</span> f<span class="delimiter">:</span>  <span class="string">&quot;F_map (extdd_step f) o s = dtor_J o f&quot;</span>
<span class="keyword2">shows</span> <span class="string">&quot;F_map (extdd_step f) o cut&Sigma;&Sigma;_stepOc s = dtor_J o (extdd_step f)&quot;</span>
<span class="command">proof</span>-
  <span class="command">have</span> AA<span class="delimiter">:</span> <span class="string">&quot;eval_step ** F_map eval_step o (&Sigma;&Sigma;_step_map f ** F_map (&Sigma;&Sigma;_step_map f) o &lt;leaf_step , s&gt;) =
            &lt;f , F_map eval_step o (F_map (&Sigma;&Sigma;_step_map f) o s)&gt;&quot;</span>
  <span class="command">unfolding</span> map_prod_o_convol <span class="command">unfolding</span> leaf_step_natural o_assoc eval_step_leaf_step id_o  <span class="command">..</span>
  <span class="command">show</span> <span class="var">?thesis</span>
  <span class="command">unfolding</span> extdd_step_def
  <span class="command">unfolding</span> o_assoc eval_step<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> &Sigma;&Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> convol_comp<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> id_o
  <span class="command">unfolding</span> f<span class="delimiter">[</span>symmetric<span class="delimiter">,</span> unfolded extdd_step_def<span class="delimiter">]</span>
  <span class="command">unfolding</span> o_assoc
  <span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> F_map_comp o_assoc
  <span class="command">unfolding</span> cut&Sigma;&Sigma;_stepOc_def
  <span class="command">unfolding</span> o_assoc
  <span class="command">unfolding</span> F_map_comp<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> flat_step_natural<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> o_assoc F_map_comp
  <span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">,</span> subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">,</span> subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> dd_step_natural<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> o_assoc <span class="command">unfolding</span> F_map_comp<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> eval_step_flat_step
  <span class="command">unfolding</span> F_map_comp <span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> dd_step_natural<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> &Sigma;&Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> AA<span class="delimiter">[</span>unfolded o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">]</span> <span class="command">..</span>
<span class="command">qed</span>

<span class="command">lemma</span> mor_cut&Sigma;&Sigma;_stepOc_flat_step<span class="delimiter">:</span>
<span class="keyword2">assumes</span> f&#39;<span class="delimiter">:</span> <span class="string">&quot;F_map f&#39; o cut&Sigma;&Sigma;_stepOc s = dtor_J o f&#39;&quot;</span>
<span class="keyword2">shows</span> <span class="string">&quot;eval_step o &Sigma;&Sigma;_step_map f&#39; = f&#39; o flat_step&quot;</span>
<span class="command">proof</span><span class="delimiter">(</span>rule trans<span class="delimiter">)</span> <span class="comment">(* this proof is clearly improvable: *)</span>
  <span class="command">def</span> h <span class="delimiter">&equiv;</span> <span class="string">&quot;dd_step o &Sigma;&Sigma;_step_map &lt;id,cut&Sigma;&Sigma;_stepOc s&gt;&quot;</span>
  <span class="command">have</span> f&#39;_id<span class="delimiter">:</span> <span class="string">&quot;f&#39; = f&#39; o id&quot;</span> <span class="command">by</span> simp
  <span class="command">show</span> <span class="string">&quot;eval_step o &Sigma;&Sigma;_step_map f&#39; = dtor_unfold_J h&quot;</span>
  <span class="command">apply</span><span class="delimiter">(</span>rule J.dtor_unfold_unique<span class="delimiter">,</span> rule sym<span class="delimiter">)</span>
  <span class="command">unfolding</span> o_assoc eval_step<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> &Sigma;&Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> convol_comp_id1<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> f&#39;<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">apply</span><span class="delimiter">(</span>subst f&#39;_id<span class="delimiter">)</span>
  <span class="command">unfolding</span> o_assoc &Sigma;&Sigma;_step.map_comp0
  <span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> F_map_comp
  <span class="command">unfolding</span> h_def <span class="command">apply</span><span class="delimiter">(</span>rule sym<span class="delimiter">)</span>
  <span class="command">unfolding</span> o_assoc <span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> dd_step_natural<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> &Sigma;&Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> map_prod_o_convol <span class="command">..</span>
  <span class="comment">(*  *)</span>
  <span class="command">have</span> AA<span class="delimiter">:</span> <span class="string">&quot;&lt;id , cut&Sigma;&Sigma;_stepOc s&gt; = (flat_step ** F_map flat_step) o (id ** dd_step) o &lt;leaf_step, &Sigma;&Sigma;_step_map &lt;leaf_step , s&gt;&gt;&quot;</span>
  <span class="command">unfolding</span> map_prod_o_convol o_assoc map_prod.comp cut&Sigma;&Sigma;_stepOc_def o_id flat_step_leaf_step <span class="command">..</span>
  <span class="command">have</span> BB<span class="delimiter">:</span> <span class="string">&quot;flat_step ** F_map flat_step o id ** dd_step o &lt;leaf_step , &Sigma;&Sigma;_step_map &lt;leaf_step , s&gt;&gt; = flat_step ** F_map flat_step o id ** dd_step o &lt;&Sigma;&Sigma;_step_map leaf_step , &Sigma;&Sigma;_step_map &lt;leaf_step , s&gt;&gt;&quot;</span>
  <span class="command">unfolding</span> map_prod.comp <span class="command">unfolding</span> map_prod_o_convol <span class="command">unfolding</span> o_id <span class="command">unfolding</span> flat_step_leaf_step leaf_step_flat_step <span class="command">..</span>
  <span class="command">show</span> <span class="string">&quot;dtor_unfold_J h = f&#39; o flat_step&quot;</span>
  <span class="command">apply</span><span class="delimiter">(</span>rule J.dtor_unfold_unique<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">,</span> rule sym<span class="delimiter">)</span>
  <span class="command">unfolding</span> o_assoc f&#39;<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> F_map_comp o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">apply</span><span class="delimiter">(</span>rule arg_cong<span class="delimiter">[</span>of _ _ <span class="string">&quot;op o (F_map f&#39;)&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> h_def
  <span class="command">unfolding</span> AA BB
  <span class="command">unfolding</span> &Sigma;&Sigma;_step.map_comp0 <span class="command">apply</span><span class="delimiter">(</span>rule sym<span class="delimiter">)</span>
  <span class="command">unfolding</span> o_assoc <span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> dd_step_natural
  <span class="command">unfolding</span> o_assoc F_map_comp<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> flat_step_assoc <span class="command">unfolding</span> F_map_comp
  <span class="command">unfolding</span> cut&Sigma;&Sigma;_stepOc_def o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">apply</span><span class="delimiter">(</span>rule arg_cong<span class="delimiter">[</span>of _ _ <span class="string">&quot;op o (F_map flat_step)&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> o_assoc
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> &Sigma;&Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> map_prod_o_convol id_o
  <span class="command">unfolding</span> flat_step_natural<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> o_assoc
  <span class="command">unfolding</span> dd_step_flat_step<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> &Sigma;&Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> convol_o <span class="command">unfolding</span> &Sigma;&Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> fst_convol <span class="command">..</span>
<span class="command">qed</span>

<span class="comment">(* restr is wedd_step-defined:  *)</span>
<span class="command">lemma</span> restr_mor<span class="delimiter">:</span>
<span class="keyword2">assumes</span> f&#39;<span class="delimiter">:</span> <span class="string">&quot;F_map f&#39; o cut&Sigma;&Sigma;_stepOc s = dtor_J o f&#39;&quot;</span>
<span class="keyword2">shows</span> <span class="string">&quot;F_map (extdd_step (restr f&#39;)) o s = dtor_J o restr f&#39;&quot;</span>
<span class="command">unfolding</span> extdd_step_def restr_def &Sigma;&Sigma;_step.map_comp0
<span class="command">unfolding</span> o_assoc mor_cut&Sigma;&Sigma;_stepOc_flat_step<span class="delimiter">[</span>OF f&#39;<span class="delimiter">]</span>
<span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> leaf_step_flat_step o_id
<span class="command">unfolding</span> o_assoc f&#39;<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
<span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> c&Sigma;&Sigma;_stepOcut_cut&Sigma;&Sigma;_stepOc<span class="delimiter">[</span>unfolded c&Sigma;&Sigma;_stepOcut_def<span class="delimiter">]</span> <span class="command">..</span>

<span class="command">lemma</span> extdd_step_restr<span class="delimiter">:</span>
<span class="keyword2">assumes</span> f&#39;<span class="delimiter">:</span> <span class="string">&quot;F_map f&#39; o cut&Sigma;&Sigma;_stepOc s = dtor_J o f&#39;&quot;</span>
<span class="keyword2">shows</span> <span class="string">&quot;extdd_step (restr f&#39;) = f&#39;&quot;</span>
<span class="command">proof</span>-
  <span class="command">have</span> <span class="string">&quot;f&#39; = eval_step o &Sigma;&Sigma;_step_map f&#39; o leaf_step&quot;</span>
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> leaf_step_natural
  <span class="command">unfolding</span> o_assoc eval_step_leaf_step <span class="command">by</span> simp
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;... = eval_step o &Sigma;&Sigma;_step_map (f&#39; o leaf_step)&quot;</span>
  <span class="command">unfolding</span> &Sigma;&Sigma;_step.map_comp0 o_assoc
  <span class="command">unfolding</span> mor_cut&Sigma;&Sigma;_stepOc_flat_step<span class="delimiter">[</span>OF f&#39;<span class="delimiter">]</span> <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> flat_step_leaf_step leaf_step_flat_step <span class="command">..</span>
  <span class="command">finally</span> <span class="command">have</span> A<span class="delimiter">:</span> <span class="string">&quot;f&#39; = eval_step o &Sigma;&Sigma;_step_map (f&#39; o leaf_step)&quot;</span> <span class="command">.</span>
  <span class="command">show</span> <span class="var">?thesis</span> <span class="command">unfolding</span> extdd_step_def restr_def A<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">..</span>
<span class="command">qed</span>

<span class="command">lemma</span> restr_inj<span class="delimiter">:</span>
<span class="keyword2">assumes</span> f_step&#39;<span class="delimiter">:</span> <span class="string">&quot;F_map f_step&#39; o cut&Sigma;&Sigma;_stepOc s = dtor_J o f_step&#39;&quot;</span>
<span class="keyword2">and</span> f2&#39;<span class="delimiter">:</span> <span class="string">&quot;F_map f2&#39; o cut&Sigma;&Sigma;_stepOc s = dtor_J o f2&#39;&quot;</span>
<span class="keyword2">shows</span> <span class="string">&quot;restr f_step&#39; = restr f2&#39; &lt;-&gt; f_step&#39; = f2&#39;&quot;</span>
<span class="command">using</span> extdd_step_restr<span class="delimiter">[</span>OF f_step&#39;<span class="delimiter">]</span> extdd_step_restr<span class="delimiter">[</span>OF f2&#39;<span class="delimiter">]</span> <span class="command">by</span> metis

<span class="command">lemma</span> extdd_step_surj<span class="delimiter">:</span>
<span class="keyword2">assumes</span> f&#39;<span class="delimiter">:</span> <span class="string">&quot;F_map f&#39; o cut&Sigma;&Sigma;_stepOc s = dtor_J o f&#39;&quot;</span>
<span class="keyword2">shows</span> <span class="string">&quot;&exist; f. extdd_step f = f&#39;&quot;</span>
<span class="command">using</span> extdd_step_restr<span class="delimiter">[</span>OF f&#39;<span class="delimiter">]</span> <span class="command">by</span><span class="delimiter">(</span>rule exI<span class="delimiter">[</span>of _ <span class="string">&quot;restr f&#39;&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>

<span class="command">lemma</span> restr_extdd_step<span class="delimiter">:</span>
<span class="keyword2">assumes</span> f<span class="delimiter">:</span> <span class="string">&quot;F_map (extdd_step f) o s = dtor_J o f&quot;</span>
<span class="keyword2">shows</span> <span class="string">&quot;restr (extdd_step f) = f&quot;</span>
<span class="command">proof</span>-
  <span class="command">have</span> <span class="string">&quot;dtor_J o f = F_map (extdd_step f) o s&quot;</span> <span class="command">using</span> assms <span class="command">unfolding</span> extdd_step_def <span class="command">by</span> <span class="delimiter">(</span>rule sym<span class="delimiter">)</span>
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;... = dtor_J o restr (extdd_step f)&quot;</span>
  <span class="command">unfolding</span> restr_def <span class="command">unfolding</span> o_assoc extdd_step_mor<span class="delimiter">[</span>OF f<span class="delimiter">,</span> symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> c&Sigma;&Sigma;_stepOcut_cut&Sigma;&Sigma;_stepOc<span class="delimiter">[</span>unfolded c&Sigma;&Sigma;_stepOcut_def<span class="delimiter">]</span> <span class="command">..</span>
  <span class="command">finally</span> <span class="command">have</span> <span class="string">&quot;dtor_J o f = dtor_J o restr (extdd_step f)&quot;</span> <span class="command">.</span>
  <span class="command">thus</span> <span class="var">?thesis</span> <span class="command">unfolding</span> dtor_J_o_inj <span class="command">by</span> <span class="delimiter">(</span>rule sym<span class="delimiter">)</span>
<span class="command">qed</span>

<span class="command">lemma</span> extdd_step_inj<span class="delimiter">:</span>
<span class="keyword2">assumes</span> f1<span class="delimiter">:</span> <span class="string">&quot;F_map (extdd_step f1) o s = dtor_J o f1&quot;</span>
<span class="keyword2">and</span> f2<span class="delimiter">:</span> <span class="string">&quot;F_map (extdd_step f2) o s = dtor_J o f2&quot;</span>
<span class="keyword2">shows</span> <span class="string">&quot;extdd_step f1 = extdd_step f2 &lt;-&gt; f1 = f2&quot;</span>
<span class="command">using</span> restr_extdd_step<span class="delimiter">[</span>OF f1<span class="delimiter">]</span> restr_extdd_step<span class="delimiter">[</span>OF f2<span class="delimiter">]</span> <span class="command">by</span> metis

<span class="command">lemma</span> restr_surj<span class="delimiter">:</span>
<span class="keyword2">assumes</span> f<span class="delimiter">:</span> <span class="string">&quot;F_map (extdd_step f) o s = dtor_J o f&quot;</span>
<span class="keyword2">shows</span> <span class="string">&quot;&exist; f&#39;. restr f&#39; = f&quot;</span>
<span class="command">using</span> restr_extdd_step<span class="delimiter">[</span>OF f<span class="delimiter">]</span> <span class="command">by</span><span class="delimiter">(</span>rule exI<span class="delimiter">[</span>of _ <span class="string">&quot;extdd_step f&quot;</span><span class="delimiter">]</span><span class="delimiter">)</span>


<span class="command">subsection</span><span class="verbatim">{* Coiteration up-to *}</span>

<span class="command">definition</span> <span class="string">&quot;unfoldU_step s &equiv; restr (dtor_unfold_J (cut&Sigma;&Sigma;_stepOc s))&quot;</span>

<span class="command">theorem</span> unfoldU_step_pointfree<span class="delimiter">:</span>
<span class="string">&quot;F_map (extdd_step (unfoldU_step s)) o s = dtor_J o unfoldU_step s&quot;</span>
<span class="command">unfolding</span> unfoldU_step_def <span class="command">apply</span><span class="delimiter">(</span>rule restr_mor<span class="delimiter">)</span>
<span class="command">unfolding</span> dtor_unfold_J_pointfree <span class="command">..</span>

<span class="command">theorem</span> unfoldU_step<span class="delimiter">:</span> <span class="string">&quot;F_map (extdd_step (unfoldU_step s)) (s a) = dtor_J (unfoldU_step s a)&quot;</span>
<span class="command">using</span> unfoldU_step_pointfree <span class="command">unfolding</span> o_def fun_eq_iff <span class="command">by</span><span class="delimiter">(</span>rule allE<span class="delimiter">)</span>

<span class="command">theorem</span> unfoldU_step_ctor_J<span class="delimiter">:</span>
<span class="string">&quot;ctor_J (F_map (extdd_step (unfoldU_step s)) (s a)) = unfoldU_step s a&quot;</span>
<span class="command">using</span> unfoldU_step <span class="command">by</span> <span class="delimiter">(</span>metis J.ctor_dtor<span class="delimiter">)</span>

<span class="command">theorem</span> unfoldU_step_unique<span class="delimiter">:</span>
<span class="keyword2">assumes</span> <span class="string">&quot;F_map (extdd_step f) o s = dtor_J o f&quot;</span>
<span class="keyword2">shows</span> <span class="string">&quot;f = unfoldU_step s&quot;</span>
<span class="command">proof</span>-
  <span class="command">note</span> f <span class="delimiter">=</span> extdd_step_mor<span class="delimiter">[</span>OF assms<span class="delimiter">]</span>  <span class="command">note</span> co <span class="delimiter">=</span> extdd_step_mor<span class="delimiter">[</span>OF unfoldU_step_pointfree<span class="delimiter">]</span>
  <span class="command">have</span> A<span class="delimiter">:</span> <span class="string">&quot;extdd_step f = extdd_step (unfoldU_step s)&quot;</span>
  <span class="command">proof</span><span class="delimiter">(</span>rule trans<span class="delimiter">)</span>
    <span class="command">show</span> <span class="string">&quot;extdd_step f = dtor_unfold_J (cut&Sigma;&Sigma;_stepOc s)&quot;</span> <span class="command">apply</span><span class="delimiter">(</span>rule J.dtor_unfold_unique<span class="delimiter">)</span> <span class="command">using</span> f <span class="command">.</span>
    <span class="command">show</span> <span class="string">&quot;dtor_unfold_J (cut&Sigma;&Sigma;_stepOc s) = extdd_step (unfoldU_step s)&quot;</span>
     <span class="command">apply</span><span class="delimiter">(</span>rule J.dtor_unfold_unique<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span> <span class="command">using</span> co <span class="command">.</span>
  <span class="command">qed</span>
  <span class="command">show</span> <span class="var">?thesis</span> <span class="command">using</span> A <span class="command">unfolding</span> extdd_step_inj<span class="delimiter">[</span>OF assms unfoldU_step_pointfree<span class="delimiter">]</span> <span class="command">.</span>
<span class="command">qed</span>

<span class="command">lemma</span> unfoldU_step_ctor_J_pointfree<span class="delimiter">:</span>
<span class="string">&quot;ctor_J o F_map (extdd_step (unfoldU_step s)) o s = unfoldU_step s&quot;</span>
<span class="command">unfolding</span> o_def fun_eq_iff <span class="command">by</span> <span class="delimiter">(</span>subst unfoldU_step_ctor_J<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">(</span>rule allI<span class="delimiter">,</span> rule refl<span class="delimiter">)</span>

<span class="comment">(* Corecursion up to: *)</span>
<span class="command">definition</span> corecU_step <span class="delimiter">::</span> <span class="string">&quot;(&#39;a =&gt; (J + &#39;a) &Sigma;&Sigma;_step F) =&gt; &#39;a =&gt; J&quot;</span> <span class="keyword2">where</span>
<span class="string">&quot;corecU_step s = unfoldU_step (case_sum (dd_step o leaf_step o &lt;Inl, F_map Inl o dtor_J&gt;) s) o Inr&quot;</span>

<span class="command">definition</span> extddRec_step <span class="keyword2">where</span>
<span class="string">&quot;extddRec_step f &equiv; eval_step o &Sigma;&Sigma;_step_map (case_sum id f)&quot;</span>

<span class="command">lemma</span> unfoldU_step_Inl<span class="delimiter">:</span>
<span class="string">&quot;unfoldU_step (case_sum (dd_step o leaf_step o &lt;Inl , F_map Inl o dtor_J&gt;) s) o Inl = id&quot;</span>
<span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L = ?R&quot;</span><span class="delimiter">)</span>
<span class="command">proof</span>-
  <span class="command">have</span> <span class="string">&quot;?L = unfoldU_step (dd_step o leaf_step o &lt;id, dtor_J&gt;)&quot;</span>
  <span class="command">apply</span><span class="delimiter">(</span>rule unfoldU_step_unique<span class="delimiter">)</span>
  <span class="command">unfolding</span> o_assoc unfoldU_step_pointfree<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> case_sum_o_inj extdd_step_def F_map_comp &Sigma;&Sigma;_step.map_comp0
  <span class="command">unfolding</span> o_assoc <span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">,</span> subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">,</span> subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">,</span>
                          subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">,</span> subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">,</span> subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">unfolding</span> dd_step_natural<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span> <span class="command">unfolding</span> leaf_step_natural
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> map_prod_o_convol o_id <span class="command">..</span>
  <span class="command">also</span> <span class="command">have</span> <span class="string">&quot;... = ?R&quot;</span>
  <span class="command">apply</span><span class="delimiter">(</span>rule sym<span class="delimiter">,</span> rule unfoldU_step_unique<span class="delimiter">)</span>
  <span class="command">unfolding</span> extdd_step_def &Sigma;&Sigma;_step.map_id0 o_id dd_step_leaf_step
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> snd_convol
  <span class="command">unfolding</span> o_assoc F_map_comp<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> eval_step_leaf_step F_map_id id_o <span class="command">..</span>
  <span class="command">finally</span> <span class="command">show</span> <span class="var">?thesis</span> <span class="command">.</span>
<span class="command">qed</span>

<span class="command">theorem</span> corecU_step_pointfree<span class="delimiter">:</span>
<span class="string">&quot;F_map (extddRec_step (corecU_step s)) o s = dtor_J o corecU_step s&quot;</span> <span class="delimiter">(</span><span class="keyword2">is</span> <span class="string">&quot;?L = ?R&quot;</span><span class="delimiter">)</span>
<span class="command">unfolding</span> corecU_step_def
<span class="command">unfolding</span> o_assoc unfoldU_step_pointfree<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> extddRec_step_def
<span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> case_sum_o_inj
<span class="command">apply</span><span class="delimiter">(</span>subst unfoldU_step_Inl<span class="delimiter">[</span>symmetric<span class="delimiter">,</span> of s<span class="delimiter">]</span><span class="delimiter">)</span>
<span class="command">unfolding</span> o_assoc case_sum_Inl_Inr_L extdd_step_def <span class="command">..</span>

<span class="command">theorem</span> corecU_step<span class="delimiter">:</span>
<span class="string">&quot;F_map (extddRec_step (corecU_step s)) (s a) = dtor_J (corecU_step s a)&quot;</span>
<span class="command">using</span> corecU_step_pointfree <span class="command">unfolding</span> o_def fun_eq_iff <span class="command">by</span><span class="delimiter">(</span>rule allE<span class="delimiter">)</span>


<span class="command">subsection</span><span class="verbatim">{* Coinduction up-to *}</span>

<span class="command">definition</span> <span class="string">&quot;cptdd_step R &equiv; (&Sigma;&Sigma;_step_rel R ===&gt; R) eval_step eval_step&quot;</span>

<span class="command">definition</span> <span class="string">&quot;cngdd_step R &equiv; equivp R &and; cptdd_step R&quot;</span>

<span class="command">lemma</span> cngdd_step_Retr<span class="delimiter">:</span> <span class="string">&quot;cngdd_step R ==&gt; cngdd_step (R \&lt;sqinter&gt; Retr R)&quot;</span>
  <span class="command">unfolding</span> cngdd_step_def cptdd_step_def
  <span class="command">apply</span> <span class="delimiter">(</span>erule conjE<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>rule conjI<span class="delimiter">[</span>OF equivp_inf<span class="delimiter">[</span>OF _ equivp_retr<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">apply</span> assumption
  <span class="command">apply</span> assumption
  <span class="command">apply</span> <span class="delimiter">(</span>rule rel_funI<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>frule predicate2D<span class="delimiter">[</span>OF &Sigma;&Sigma;_step_rel_inf<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>erule inf2E<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>rule inf2I<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>erule rel_funE<span class="delimiter">)</span>
  <span class="command">apply</span> assumption
  <span class="command">apply</span> assumption
  <span class="command">apply</span> <span class="delimiter">(</span>subst Retr_def<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>subst eval_step_def<span class="delimiter">)</span><span class="delimiter">+</span>
  <span class="command">apply</span> <span class="delimiter">(</span>subst J.dtor_unfold<span class="delimiter">)</span><span class="delimiter">+</span>
  <span class="command">unfolding</span> F_rel_F_map_F_map Grp_def relcompp.simps<span class="delimiter">[</span>abs_def<span class="delimiter">]</span> conversep.simps<span class="delimiter">[</span>abs_def<span class="delimiter">]</span>
  <span class="command">apply</span> auto
  <span class="command">unfolding</span> eval_step_def<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">apply</span> <span class="delimiter">(</span>rule predicate2D<span class="delimiter">[</span>OF F_rel_mono<span class="delimiter">]</span><span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>rule predicate2I<span class="delimiter">)</span>
  <span class="command">apply</span> <span class="delimiter">(</span>erule rel_funD<span class="delimiter">)</span>
  <span class="command">apply</span> assumption
  <span class="command">apply</span> <span class="delimiter">(</span>rule F_rel_&Sigma;&Sigma;_step_rel<span class="delimiter">)</span>
  <span class="command">unfolding</span> &Sigma;&Sigma;_step_rel_&Sigma;&Sigma;_step_map_&Sigma;&Sigma;_step_map vimage2p_rel_prod vimage2p_id
  <span class="command">unfolding</span> vimage2p_def Retr_def<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
  <span class="command">apply</span> assumption
  <span class="command">done</span>

<span class="comment">(* The generated congruence: *)</span>
<span class="command">definition</span> <span class="string">&quot;genCngdd_step R j1 j2 &equiv; &forall; R&#39;. R &le; R&#39; &and; cngdd_step R&#39; --&gt; R&#39; j1 j2&quot;</span>

<span class="command">lemma</span> cngdd_step_genCngdd_step<span class="delimiter">:</span> <span class="string">&quot;cngdd_step (genCngdd_step R)&quot;</span>
<span class="command">unfolding</span> cngdd_step_def <span class="command">proof</span> safe
  <span class="command">show</span> <span class="string">&quot;cptdd_step (genCngdd_step R)&quot;</span>
  <span class="command">unfolding</span> cptdd_step_def rel_fun_def <span class="command">proof</span> safe
    <span class="command">fix</span> x y <span class="command">assume</span> A<span class="delimiter">:</span> <span class="string">&quot;&Sigma;&Sigma;_step_rel (genCngdd_step R) x y&quot;</span>
    <span class="command">show</span> <span class="string">&quot;genCngdd_step R (eval_step x) (eval_step y)&quot;</span>
    <span class="command">unfolding</span> genCngdd_step_def<span class="delimiter">[</span>abs_def<span class="delimiter">]</span> <span class="command">proof</span> safe
      <span class="command">fix</span> R&#39; <span class="command">assume</span> <span class="string">&quot;R &le; R&#39;&quot;</span> <span class="keyword2">and</span> 2<span class="delimiter">:</span> <span class="string">&quot;cngdd_step R&#39;&quot;</span>
      <span class="command">hence</span> <span class="string">&quot;&Sigma;&Sigma;_step_rel R&#39; x y&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>metis A &Sigma;&Sigma;_step.rel_mono_strong genCngdd_step_def<span class="delimiter">)</span>
      <span class="command">thus</span> <span class="string">&quot;R&#39; (eval_step x) (eval_step y)&quot;</span> <span class="command">using</span> 2 <span class="command">unfolding</span> cngdd_step_def cptdd_step_def rel_fun_def <span class="command">by</span> auto
    <span class="command">qed</span>
  <span class="command">qed</span>
<span class="command">qed</span><span class="delimiter">(</span>rule equivpI<span class="delimiter">,</span> unfold reflp_def symp_def transp_def genCngdd_step_def cngdd_step_def equivp_def<span class="delimiter">,</span> auto<span class="delimiter">)</span>

<span class="command">lemma</span>
    genCngdd_step_refl<span class="delimiter">[</span>intro<span class="delimiter">,</span>simp<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;genCngdd_step R j j&quot;</span>
<span class="keyword2">and</span> genCngdd_step_sym<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;genCngdd_step R j1 j2 ==&gt; genCngdd_step R j2 j1&quot;</span>
<span class="keyword2">and</span> genCngdd_step_trans<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;[|genCngdd_step R j1 j2; genCngdd_step R j2 j3|] ==&gt; genCngdd_step R j1 j3&quot;</span>
<span class="command">using</span> cngdd_step_genCngdd_step <span class="command">unfolding</span> cngdd_step_def equivp_def <span class="command">by</span> auto

<span class="command">lemma</span> genCngdd_step_eval_step_rel_fun<span class="delimiter">:</span> <span class="string">&quot;(&Sigma;&Sigma;_step_rel (genCngdd_step R) ===&gt; genCngdd_step R) eval_step eval_step&quot;</span>
<span class="command">using</span> cngdd_step_genCngdd_step <span class="command">unfolding</span> cngdd_step_def cptdd_step_def <span class="command">by</span> auto

<span class="command">lemma</span> genCngdd_step_eval_step<span class="delimiter">:</span> <span class="string">&quot;&Sigma;&Sigma;_step_rel (genCngdd_step R) x y ==&gt; genCngdd_step R (eval_step x) (eval_step y)&quot;</span>
<span class="command">using</span> genCngdd_step_eval_step_rel_fun <span class="command">unfolding</span> rel_fun_def <span class="command">by</span> auto

<span class="command">lemma</span> leq_genCngdd_step<span class="delimiter">:</span> <span class="string">&quot;R &le; genCngdd_step R&quot;</span>
<span class="keyword2">and</span> imp_genCngdd_step<span class="delimiter">[</span>intro<span class="delimiter">]</span><span class="delimiter">:</span> <span class="string">&quot;R j1 j2 ==&gt; genCngdd_step R j1 j2&quot;</span>
<span class="command">unfolding</span> genCngdd_step_def<span class="delimiter">[</span>abs_def<span class="delimiter">]</span> <span class="command">by</span> auto

<span class="command">lemma</span> genCngdd_step_minimal<span class="delimiter">:</span> <span class="string">&quot;[|R &le; R&#39;; cngdd_step R&#39;|] ==&gt; genCngdd_step R &le; R&#39;&quot;</span>
<span class="command">unfolding</span> genCngdd_step_def<span class="delimiter">[</span>abs_def<span class="delimiter">]</span> <span class="command">by</span> <span class="delimiter">(</span>metis <span class="delimiter">(</span>lifting<span class="delimiter">,</span> no_types<span class="delimiter">)</span> predicate2I<span class="delimiter">)</span>

<span class="command">theorem</span> coinductionU_genCngdd_step<span class="delimiter">:</span>
<span class="keyword2">assumes</span> <span class="string">&quot;&forall; a b. R a b --&gt; F_rel (genCngdd_step R) (dtor_J a) (dtor_J b)&quot;</span>
<span class="keyword2">shows</span> <span class="string">&quot;R a b --&gt; a = b&quot;</span>
<span class="command">proof</span>-
  <span class="command">let</span> <span class="var">?R&#39;</span> <span class="delimiter">=</span> <span class="string">&quot;genCngdd_step R&quot;</span>
  <span class="command">have</span> <span class="string">&quot;R &le; Retr ?R&#39;&quot;</span> <span class="command">using</span> assms <span class="command">unfolding</span> Retr_def<span class="delimiter">[</span>abs_def<span class="delimiter">]</span> <span class="command">by</span> auto
  <span class="command">hence</span> <span class="string">&quot;R &le; ?R&#39; \&lt;sqinter&gt; Retr ?R&#39;&quot;</span> <span class="command">using</span> leq_genCngdd_step <span class="command">by</span> auto
  <span class="command">moreover</span> <span class="command">have</span> <span class="string">&quot;cngdd_step (?R&#39; \&lt;sqinter&gt; Retr ?R&#39;)&quot;</span> <span class="command">using</span> cngdd_step_Retr<span class="delimiter">[</span>OF cngdd_step_genCngdd_step<span class="delimiter">[</span>of R<span class="delimiter">]</span><span class="delimiter">]</span> <span class="command">.</span>
  <span class="command">ultimately</span> <span class="command">have</span> <span class="string">&quot;?R&#39; &le; ?R&#39; \&lt;sqinter&gt; Retr ?R&#39;&quot;</span> <span class="command">using</span> genCngdd_step_minimal <span class="command">by</span> metis
  <span class="command">hence</span> <span class="string">&quot;?R&#39; &le; Retr ?R&#39;&quot;</span> <span class="command">by</span> auto
  <span class="command">hence</span> <span class="string">&quot;?R&#39; a b --&gt; a = b&quot;</span>  <span class="command">unfolding</span> Retr_def<span class="delimiter">[</span>abs_def<span class="delimiter">]</span> <span class="command">by</span> <span class="delimiter">(</span>intro J.dtor_coinduct<span class="delimiter">)</span> auto
  <span class="command">thus</span> <span class="var">?thesis</span> <span class="command">using</span> leq_genCngdd_step <span class="command">by</span> auto
<span class="command">qed</span>


<span class="command">subsection</span><span class="verbatim">{* Flattening from term algebra to &quot;one-step&quot; algebra *}</span>

<span class="comment">(* Since (J &Sigma;&Sigma;_step, eval_step) is an Eilenberg-Moore algebra (i.e., is compatible with
the monadic structure, it yields an algebra on the signature functor.
This is crucial for having suitable simplification rules. *)</span>

<span class="comment">(* The one-step algebra (naturally associated to &Lambda;_step, not to dd_step): *)</span>
<span class="command">definition</span> alg&Lambda;_step <span class="delimiter">::</span> <span class="string">&quot;J &Sigma;_step =&gt; J&quot;</span> <span class="keyword2">where</span> <span class="string">&quot;alg&Lambda;_step = eval_step o \&lt;oo&gt;\&lt;pp&gt;_step o &Sigma;_step_map leaf_step&quot;</span>

<span class="command">theorem</span> eval_step_comp_\&lt;oo&gt;\&lt;pp&gt;_step<span class="delimiter">:</span> <span class="string">&quot;eval_step o \&lt;oo&gt;\&lt;pp&gt;_step = alg&Lambda;_step o &Sigma;_step_map eval_step&quot;</span>
<span class="command">unfolding</span> alg&Lambda;_step_def
<span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> &Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
<span class="command">unfolding</span> leaf_step_natural<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">unfolding</span> &Sigma;_step.map_comp0
<span class="command">apply</span><span class="delimiter">(</span>rule sym<span class="delimiter">)</span> <span class="command">unfolding</span> o_assoc <span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span>
<span class="command">unfolding</span> \&lt;oo&gt;\&lt;pp&gt;_step_natural
<span class="command">unfolding</span> o_assoc eval_step_flat_step<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
<span class="command">apply</span><span class="delimiter">(</span>subst o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span> <span class="command">unfolding</span> flat_step_commute<span class="delimiter">[</span>symmetric<span class="delimiter">]</span>
<span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> &Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> flat_step_leaf_step &Sigma;_step.map_id0 o_id <span class="command">..</span>

<span class="command">theorem</span> eval_step_\&lt;oo&gt;\&lt;pp&gt;_step<span class="delimiter">:</span> <span class="string">&quot;eval_step (\&lt;oo&gt;\&lt;pp&gt;_step t) = alg&Lambda;_step (&Sigma;_step_map eval_step t)&quot;</span>
<span class="command">using</span> eval_step_comp_\&lt;oo&gt;\&lt;pp&gt;_step <span class="command">unfolding</span> o_def fun_eq_iff <span class="command">by</span> <span class="delimiter">(</span>rule allE<span class="delimiter">)</span>

<span class="command">theorem</span> eval_step_leaf_step&#39;<span class="delimiter">:</span> <span class="string">&quot;eval_step (leaf_step j) = j&quot;</span>
<span class="command">using</span> eval_step_leaf_step <span class="command">unfolding</span> o_def fun_eq_iff id_def <span class="command">by</span> <span class="delimiter">(</span>rule allE<span class="delimiter">)</span>

<span class="command">theorem</span> dtor_J_alg&Lambda;_step<span class="delimiter">:</span> <span class="string">&quot;dtor_J o alg&Lambda;_step = F_map eval_step o &Lambda;_step o &Sigma;_step_map &lt;id, dtor_J&gt;&quot;</span>
  <span class="command">unfolding</span> alg&Lambda;_step_def eval_step_def o_assoc dtor_unfold_J_pointfree &Lambda;_step_dd_step
  <span class="command">unfolding</span> o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> \&lt;oo&gt;\&lt;pp&gt;_step_natural<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> &Sigma;_step.map_comp0<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> leaf_step_natural
  <span class="command">..</span>

<span class="command">theorem</span> dtor_J_alg&Lambda;_step&#39;<span class="delimiter">:</span> <span class="string">&quot;dtor_J (alg&Lambda;_step t) = F_map eval_step (&Lambda;_step (&Sigma;_step_map (&lt;id, dtor_J&gt;) t))&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>rule trans<span class="delimiter">[</span>OF o_eq_dest<span class="delimiter">[</span>OF dtor_J_alg&Lambda;_step<span class="delimiter">]</span> o_apply<span class="delimiter">]</span><span class="delimiter">)</span>

<span class="command">theorem</span> ctor_J_alg&Lambda;_step<span class="delimiter">:</span> <span class="string">&quot;alg&Lambda;_step t = ctor_J (F_map eval_step (&Lambda;_step (&Sigma;_step_map (&lt;id, dtor_J&gt;) t)))&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>rule iffD1<span class="delimiter">[</span>OF J.dtor_inject trans<span class="delimiter">[</span>OF dtor_J_alg&Lambda;_step&#39; J.dtor_ctor<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>

<span class="comment">(* Note: The user wi&Lambda;_step indicate an &quot;equation&quot; equ :: J &Sigma;_step =&gt; (J &Sigma;&Sigma;_step) F
in order to define the operation alg&Lambda;_step :: J &Sigma;_step =&gt; J on the final coalgebra
according to dtor_J_alg&Lambda;_step.
The package wi&Lambda;_step identify the polymorphic function &Lambda;_step :: (&#39;a &times; &#39;a F) &Sigma;_step =&gt; &#39;a &Sigma;&Sigma;_step F
such that equ = &Lambda;_step o &Sigma;_step &lt;id, dtor_J&gt;. Then the package wi&Lambda;_step attempt to prove
automatica&Lambda;_stepy that &Lambda;_step is natural.  If the proof fails, the user wi&Lambda;_step be asked to prove it.
Upon success, the distributive law is being registered.
*)</span>

<span class="comment">(* Customizing coinduction up-to: *)</span>
<span class="command">definition</span> <span class="string">&quot;cpt&Lambda;_step R &equiv; (&Sigma;_step_rel R ===&gt; R) alg&Lambda;_step alg&Lambda;_step&quot;</span>

<span class="command">definition</span> <span class="string">&quot;cng&Lambda;_step R &equiv; equivp R &and; cpt&Lambda;_step R&quot;</span>

<span class="command">lemma</span> cptdd_step_iff_cpt&Lambda;_step<span class="delimiter">:</span> <span class="string">&quot;cptdd_step R &lt;-&gt; cpt&Lambda;_step R&quot;</span>
<span class="command">apply</span> <span class="delimiter">(</span>rule iffI<span class="delimiter">)</span>
<span class="command">apply</span> <span class="delimiter">(</span>unfold cpt&Lambda;_step_def cptdd_step_def alg&Lambda;_step_def o_assoc<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">)</span> <span class="delimiter">[</span>1<span class="delimiter">]</span>
<span class="command">apply</span> <span class="delimiter">(</span>erule rel_funD<span class="delimiter">[</span>OF rel_funD<span class="delimiter">[</span>OF comp_transfer<span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span>
<span class="command">apply</span> transfer_prover

<span class="command">apply</span> <span class="delimiter">(</span>unfold cpt&Lambda;_step_def cptdd_step_def<span class="delimiter">)</span> <span class="delimiter">[</span>1<span class="delimiter">]</span>
<span class="command">unfolding</span> rel_fun_def
<span class="command">apply</span> <span class="delimiter">(</span>rule allI<span class="delimiter">)</span><span class="delimiter">+</span>
<span class="command">apply</span> <span class="delimiter">(</span>rule &Sigma;&Sigma;_step_rel_induct<span class="delimiter">)</span>
<span class="command">apply</span> <span class="delimiter">(</span>simp only<span class="delimiter">:</span> eval_step_leaf_step&#39;<span class="delimiter">)</span>
<span class="command">unfolding</span> eval_step_\&lt;oo&gt;\&lt;pp&gt;_step
<span class="command">apply</span> <span class="delimiter">(</span>drule spec2<span class="delimiter">)</span>
<span class="command">apply</span> <span class="delimiter">(</span>erule mp<span class="delimiter">)</span>
<span class="command">apply</span> <span class="delimiter">(</span>rule iffD2<span class="delimiter">[</span>OF &Sigma;_step_rel_&Sigma;_step_map_&Sigma;_step_map<span class="delimiter">]</span><span class="delimiter">)</span>
<span class="command">apply</span> <span class="delimiter">(</span>subst vimage2p_def<span class="delimiter">)</span>
<span class="command">apply</span> assumption
<span class="command">done</span>

<span class="comment">(* This is the definition of genCngdd_step we need to work with: *)</span>
<span class="command">theorem</span> genCngdd_step_def2<span class="delimiter">:</span> <span class="string">&quot;genCngdd_step R j1 j2 &lt;-&gt; (&forall; R&#39;. R &le; R&#39; &and; cng&Lambda;_step R&#39; --&gt; R&#39; j1 j2)&quot;</span>
<span class="command">unfolding</span> genCngdd_step_def cngdd_step_def cng&Lambda;_step_def cptdd_step_iff_cpt&Lambda;_step <span class="command">..</span>


<span class="command">subsection</span> <span class="verbatim">{* Incremental coinduction *}</span>

<span class="command">interpretation</span> I_step<span class="delimiter">:</span> Incremental <span class="keyword2">where</span> Retr <span class="delimiter">=</span> Retr <span class="keyword2">and</span> Cl <span class="delimiter">=</span> genCngdd_step
<span class="command">proof</span>
  <span class="command">show</span> <span class="string">&quot;mono Retr&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>rule mono_retr<span class="delimiter">)</span>
<span class="command">next</span>
  <span class="command">show</span> <span class="string">&quot;mono genCngdd_step&quot;</span> <span class="command">unfolding</span> mono_def
  <span class="command">unfolding</span> genCngdd_step_def<span class="delimiter">[</span>abs_def<span class="delimiter">]</span> <span class="command">by</span> <span class="delimiter">(</span>smt order.trans predicate2I<span class="delimiter">)</span>
<span class="command">next</span>
  <span class="command">fix</span> r <span class="command">show</span> <span class="string">&quot;genCngdd_step (genCngdd_step r) = genCngdd_step r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>metis cngdd_step_genCngdd_step genCngdd_step_minimal leq_genCngdd_step order_class.order.antisym<span class="delimiter">)</span>
<span class="command">next</span>
  <span class="command">fix</span> r <span class="command">show</span> <span class="string">&quot;r &le; genCngdd_step r&quot;</span> <span class="command">by</span> <span class="delimiter">(</span>metis leq_genCngdd_step<span class="delimiter">)</span>
<span class="command">next</span>
  <span class="command">fix</span> r <span class="command">assume</span> <span class="string">&quot;genCngdd_step r = r&quot;</span> <span class="command">thus</span> <span class="string">&quot;genCngdd_step (r \&lt;sqinter&gt; Retr r) = r \&lt;sqinter&gt; Retr r&quot;</span>
  <span class="command">by</span> <span class="delimiter">(</span>metis antisym cngdd_step_Retr cngdd_step_genCngdd_step genCngdd_step_minimal
            inf.orderI inf_idem leq_genCngdd_step<span class="delimiter">)</span>
<span class="command">qed</span>

<span class="command">definition</span> ded_step <span class="keyword2">where</span> <span class="string">&quot;ded_step r s &equiv; I_step.ded r s&quot;</span>

<span class="command">theorems</span> Ax <span class="delimiter">=</span> I_step.Ax&#39;<span class="delimiter">[</span>unfolded ded_step_def<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">]</span>
<span class="command">theorems</span> Split <span class="delimiter">=</span> I_step.Split<span class="delimiter">[</span>unfolded ded_step_def<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">]</span>
<span class="command">theorems</span> Coind <span class="delimiter">=</span> I_step.Coind<span class="delimiter">[</span>unfolded ded_step_def<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">]</span>

<span class="command">theorem</span> soundness_ded<span class="delimiter">:</span>
<span class="keyword2">assumes</span> <span class="string">&quot;ded_step (op =) s&quot;</span>  <span class="keyword2">shows</span> <span class="string">&quot;s &le; (op =)&quot;</span>
<span class="command">unfolding</span> gfp_Retr_eq<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> <span class="command">apply</span><span class="delimiter">(</span>rule I_step.soundness_ded<span class="delimiter">[</span>unfolded ded_step_def<span class="delimiter">[</span>symmetric<span class="delimiter">]</span><span class="delimiter">]</span> <span class="delimiter">)</span>
<span class="command">using</span> assms <span class="command">unfolding</span> gfp_Retr_eq<span class="delimiter">[</span>symmetric<span class="delimiter">]</span> ded_step_def <span class="command">.</span>

<span class="command">unused_thms</span>

<span class="command">end</span>
</pre>

</div>
</body>
</html>
